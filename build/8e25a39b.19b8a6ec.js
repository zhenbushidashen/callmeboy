(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{69:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return f}));var r=t(2),o=t(6),a=(t(0),t(85)),i={id:"ref",title:"ref",tags:["vue","vue3","front-end","javascript","ref"]},l={unversionedId:"vue3/ref",id:"vue3/ref",isDocsHomePage:!1,title:"ref",description:"`typescript",source:"@site/docs/vue3/vue3-ref.md",permalink:"/blog/docs/vue3/ref",editUrl:"https://github.com/zhenbushidashen/callmeboy/tree/master/docs/vue3/vue3-ref.md",sidebar:"docs",previous:{title:"reactive",permalink:"/blog/docs/vue3/reactive"},next:{title:"Style Guide",permalink:"/blog/docs/"}},s=[],c={rightToc:s};function f(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { track, trigger } from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { isArray, isObject, hasChanged } from '@vue/shared'\nimport { reactive, isProxy, toRaw, isReactive } from './reactive'\nimport { CollectionTypes } from './collectionHandlers'\n\ndeclare const RefSymbol: unique symbol\n\nexport interface Ref<T = any> {\n  value: T\n  /**\n   * Type differentiator only.\n   * We need this to be in public d.ts but don't want it to show up in IDE\n   * autocomplete, so we use a private Symbol instead.\n   */\n  [RefSymbol]: true\n  /**\n   * @internal\n   */\n  _shallow?: boolean\n}\n\nexport type ToRefs<T = any> = { [K in keyof T]: Ref<T[K]> }\n\nconst convert = <T extends unknown>(val: T): T =>\n  isObject(val) ? reactive(val) : val\n\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nexport function isRef(r: any): r is Ref {\n  return Boolean(r && r.__v_isRef === true)\n}\n\nexport function ref<T extends object>(\n  value: T\n): T extends Ref ? T : Ref<UnwrapRef<T>>\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value)\n}\n\nexport function shallowRef<T extends object>(\n  value: T\n): T extends Ref ? T : Ref<T>\nexport function shallowRef<T>(value: T): Ref<T>\nexport function shallowRef<T = any>(): Ref<T | undefined>\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\nclass RefImpl<T> {\n  private _value: T\n\n  public readonly __v_isRef = true\n\n  constructor(private _rawValue: T, public readonly _shallow = false) {\n    this._value = _shallow ? _rawValue : convert(_rawValue)\n  }\n\n  get value() {\n    track(toRaw(this), TrackOpTypes.GET, 'value')\n    return this._value\n  }\n\n  set value(newVal) {\n    if (hasChanged(toRaw(newVal), this._rawValue)) {\n      this._rawValue = newVal\n      this._value = this._shallow ? newVal : convert(newVal)\n      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)\n    }\n  }\n}\n\nfunction createRef(rawValue: unknown, shallow = false) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nexport function triggerRef(ref: Ref) {\n  trigger(toRaw(ref), TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)\n}\n\nexport function unref<T>(ref: T): T extends Ref<infer V> ? V : T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key]\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value\n      return true\n    } else {\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n}\n\nexport function proxyRefs<T extends object>(\n  objectWithRefs: T\n): ShallowUnwrapRef<T> {\n  return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport type CustomRefFactory<T> = (\n  track: () => void,\n  trigger: () => void\n) => {\n  get: () => T\n  set: (value: T) => void\n}\n\nclass CustomRefImpl<T> {\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    const { get, set } = factory(\n      () => track(this, TrackOpTypes.GET, 'value'),\n      () => trigger(this, TriggerOpTypes.SET, 'value')\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\n\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  if (__DEV__ && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\n  }\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(private readonly _object: T, private readonly _key: K) {}\n\n  get value() {\n    return this._object[this._key]\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): Ref<T[K]> {\n  return isRef(object[key])\n    ? object[key]\n    : (new ObjectRefImpl(object, key) as any)\n}\n\n// corner case when use narrows type\n// Ex. type RelativePath = string & { __brand: unknown }\n// RelativePath extends object -> true\ntype BaseTypes = string | number | boolean\n\n/**\n * This is a special exported interface for other packages to declare\n * additional types that should bail out for ref unwrapping. For example\n * \\@vue/runtime-dom can declare it like so in its d.ts:\n *\n * ``` ts\n * declare module '@vue/reactivity' {\n *   export interface RefUnwrapBailTypes {\n *     runtimeDOMBailTypes: Node | Window\n *   }\n * }\n * ```\n *\n * Note that api-extractor somehow refuses to include `declare module`\n * augmentations in its generated d.ts, so we have to manually append them\n * to the final generated d.ts in our build process.\n */\nexport interface RefUnwrapBailTypes {}\n\nexport type ShallowUnwrapRef<T> = {\n  [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K]\n}\n\nexport type UnwrapRef<T> = T extends Ref<infer V>\n  ? UnwrapRefSimple<V>\n  : UnwrapRefSimple<T>\n\ntype UnwrapRefSimple<T> = T extends\n  | Function\n  | CollectionTypes\n  | BaseTypes\n  | Ref\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\n  ? T\n  : T extends Array<any>\n    ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\n    : T extends object ? UnwrappedObject<T> : T\n\n// Extract all known symbols from an object\n// when unwrapping Object the symbols are not `in keyof`, this should cover all the\n// known symbols\ntype SymbolExtract<T> = (T extends { [Symbol.asyncIterator]: infer V }\n  ? { [Symbol.asyncIterator]: V }\n  : {}) &\n  (T extends { [Symbol.hasInstance]: infer V }\n    ? { [Symbol.hasInstance]: V }\n    : {}) &\n  (T extends { [Symbol.isConcatSpreadable]: infer V }\n    ? { [Symbol.isConcatSpreadable]: V }\n    : {}) &\n  (T extends { [Symbol.iterator]: infer V } ? { [Symbol.iterator]: V } : {}) &\n  (T extends { [Symbol.match]: infer V } ? { [Symbol.match]: V } : {}) &\n  (T extends { [Symbol.matchAll]: infer V } ? { [Symbol.matchAll]: V } : {}) &\n  (T extends { [Symbol.replace]: infer V } ? { [Symbol.replace]: V } : {}) &\n  (T extends { [Symbol.search]: infer V } ? { [Symbol.search]: V } : {}) &\n  (T extends { [Symbol.species]: infer V } ? { [Symbol.species]: V } : {}) &\n  (T extends { [Symbol.split]: infer V } ? { [Symbol.split]: V } : {}) &\n  (T extends { [Symbol.toPrimitive]: infer V }\n    ? { [Symbol.toPrimitive]: V }\n    : {}) &\n  (T extends { [Symbol.toStringTag]: infer V }\n    ? { [Symbol.toStringTag]: V }\n    : {}) &\n  (T extends { [Symbol.unscopables]: infer V }\n    ? { [Symbol.unscopables]: V }\n    : {})\n\ntype UnwrappedObject<T> = { [P in keyof T]: UnwrapRef<T[P]> } & SymbolExtract<T>\n\n")))}f.isMDXComponent=!0},85:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return T}));var r=t(0),o=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=o.a.createContext({}),f=function(e){var n=o.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=f(e.components);return o.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},y=o.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=f(t),y=r,T=u["".concat(i,".").concat(y)]||u[y]||p[y]||a;return t?o.a.createElement(T,l(l({ref:n},c),{},{components:t})):o.a.createElement(T,l({ref:n},c))}));function T(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=y;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=t[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}y.displayName="MDXCreateElement"}}]);